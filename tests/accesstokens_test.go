//go:build itest

package tests

import (
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"

	accessAuth "github.com/jfrog/jfrog-client-go/access/auth"
	"github.com/jfrog/jfrog-client-go/access/services"
	"github.com/jfrog/jfrog-client-go/auth"
	"github.com/jfrog/jfrog-client-go/http/jfroghttpclient"
	"github.com/jfrog/jfrog-client-go/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const testExpiredInSeconds = 1

func TestAccessTokens(t *testing.T) {
	initAccessTest(t)
	t.Run("createAccessToken", testCreateRefreshableToken)
	t.Run("createAccessTokenWithReference", testAccessTokenWithReference)
	t.Run("refreshToken", testRefreshTokenTest)
	t.Run("exchangeOIDCToken", testExchangeOidcToken)
	t.Run("getTokens", testGetTokens)
	t.Run("getTokenByID", testGetTokenByID)
	t.Run("revokeTokenByID", testRevokeTokenByID)
}

// This test uses a mock response because the subject_token (TokenID) is not available in the test environment
// and should be generated by the OIDC provider.
// Additionally, for this to work, the OIDC integration needs to be defined in the platform.
// This is not supported by CLI commands, The end-to-end tests for exchanging the OIDC token
// are implemented on the CLI side.
// Using a mock response here is necessary to simulate the OIDC token exchange process.
func testExchangeOidcToken(t *testing.T) {
	initAccessTest(t)

	// Create mock server
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, http.MethodPost, r.Method)
		assert.Equal(t, "/access/api/v1/oidc/token", r.URL.Path)

		// Verify request body
		body, err := io.ReadAll(r.Body)
		assert.NoError(t, err)
		defer func() {
			assert.NoError(t, r.Body.Close())
		}()

		var req services.CreateOidcTokenParams
		err = json.Unmarshal(body, &req)
		assert.NoError(t, err)
		assert.Equal(t, "mockOidcTokenID", req.OidcTokenID)

		// Verify VCS fields are properly included
		assert.Equal(t, "https://github.com/example/repo.git", req.Repo)
		assert.Equal(t, "main", req.Branch)
		assert.Equal(t, "abc123def456", req.Revision)

		// Simulate response
		resp := auth.OidcTokenResponseData{
			CommonTokenParams: auth.CommonTokenParams{
				AccessToken: "mockAccessToken",
			},
			IssuedTokenType: "mockIssuedTokenType",
			Username:        "mockUsername",
		}
		responseBody, err := json.Marshal(resp)
		assert.NoError(t, err)

		w.WriteHeader(http.StatusOK)
		_, err = w.Write(responseBody)
		assert.NoError(t, err)
	})
	ts := httptest.NewServer(handler)
	defer ts.Close()

	// Setup JFrog client
	client, err := jfroghttpclient.JfrogClientBuilder().
		SetInsecureTls(true).
		Build()
	assert.NoError(t, err, "Failed to create JFrog client")

	// Setup TokenService
	service := services.NewTokenService(client)
	serverDetails := accessAuth.NewAccessDetails()
	serverDetails.SetUrl(ts.URL + "/access")
	service.ServiceDetails = serverDetails

	// Define OIDC token parameters
	params := services.CreateOidcTokenParams{
		GrantType:             "authorization_code",
		SubjectTokenType:      "Generic",
		OidcTokenID:           "mockOidcTokenID",
		ProviderName:          "mockProviderName",
		ProjectKey:            "mockProjectKey",
		JobId:                 "mockJobId",
		RunId:                 "mockRunId",
		Repo:                  "https://github.com/example/repo.git",
		ApplicationKey:        "mockApplicationKey",
		Audience:              "mockAudience",
		IdentityMappingName:   "mockIdentityMappingName",
		IncludeReferenceToken: utils.Pointer(false),
		Branch:                "main",
		Revision:              "abc123def456",
	}

	// Execute ExchangeOidcToken
	response, err := service.ExchangeOidcToken(params)

	// Verify response
	assert.NoError(t, err)
	assert.NotNil(t, response)
}

func testCreateRefreshableToken(t *testing.T) {
	tokenParams := createRefreshableAccessTokenParams(testExpiredInSeconds)
	token, err := testsAccessTokensService.CreateAccessToken(tokenParams)
	require.NoError(t, err)
	require.NotNil(t, token)
	assert.NotEqual(t, "", token.AccessToken, "Access token is empty")
	assert.NotEqual(t, tokenParams.AccessToken, token.AccessToken, "New access token is identical to original one")
	assert.NotEqual(t, "", token.RefreshToken, "Refresh token is empty")
	assert.EqualValues(t, testExpiredInSeconds, *token.ExpiresIn)
	assert.Empty(t, token.ReferenceToken)
}

func testAccessTokenWithReference(t *testing.T) {
	tokenParams := createRefreshableAccessTokenParams(testExpiredInSeconds)
	tokenParams.IncludeReferenceToken = utils.Pointer(true)
	token, err := testsAccessTokensService.CreateAccessToken(tokenParams)
	require.NoError(t, err)
	require.NotNil(t, token)
	assert.NotEqual(t, "", token.AccessToken, "Access token is empty")
	assert.NotEqual(t, tokenParams.AccessToken, token.AccessToken, "New access token is identical to original one")
	assert.NotEqual(t, "", token.RefreshToken, "Refresh token is empty")
	assert.EqualValues(t, testExpiredInSeconds, *token.ExpiresIn)
	assert.NotEmpty(t, token.ReferenceToken)
}

func testRefreshTokenTest(t *testing.T) {
	// Create token
	tokenParams := createRefreshableAccessTokenParams(testExpiredInSeconds)
	token, err := testsAccessTokensService.CreateAccessToken(tokenParams)
	require.NoError(t, err)
	require.NotNil(t, token)
	// Refresh token
	refreshTokenParams := createRefreshAccessTokenParams(token)
	newToken, err := testsAccessTokensService.RefreshAccessToken(refreshTokenParams)
	require.NoError(t, err)
	require.NotNil(t, newToken)
	// Validate
	assert.NotEqual(t, token.AccessToken, newToken.AccessToken, "New access token is identical to original one")
	assert.NotEqual(t, token.RefreshToken, newToken.RefreshToken, "New refresh token is identical to original one")
	assert.EqualValues(t, token.ExpiresIn, newToken.ExpiresIn, "New access token's expiration is different from original one")
	assert.Empty(t, token.ReferenceToken)
}

func testGetTokens(t *testing.T) {
	initAccessTest(t)

	// Create mock server
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, http.MethodGet, r.Method)
		assert.Equal(t, "/access/api/v1/tokens", r.URL.Path)

		// Check query parameters
		query := r.URL.Query()
		if len(query) > 0 {
			assert.Equal(t, "admin", query.Get("username"))
			assert.Equal(t, "true", query.Get("refreshable"))
			assert.Equal(t, "description", query.Get("order_by"))
			assert.Equal(t, "true", query.Get("descending_order"))
		}

		// Mock response - wrapped in TokenInfos structure
		response := services.TokenInfos{
			Tokens: []services.TokenInfo{
				{
					TokenId:     "test-token-1",
					Subject:     "jfrt@test/users/admin",
					IssuedAt:    1640995200,
					Issuer:      "jfrt@test",
					Description: "Test token 1",
					Refreshable: true,
					Scope:       "applied-permissions/admin",
				},
				{
					TokenId:     "test-token-2",
					Subject:     "jfrt@test/users/user1",
					IssuedAt:    1640995200,
					Issuer:      "jfrt@test",
					Description: "Test token 2",
					Refreshable: false,
					Scope:       "applied-permissions/user",
				},
			},
		}

		responseBody, err := json.Marshal(response)
		assert.NoError(t, err)

		w.WriteHeader(http.StatusOK)
		_, err = w.Write(responseBody)
		assert.NoError(t, err)
	})
	ts := httptest.NewServer(handler)
	defer ts.Close()

	// Setup JFrog client
	client, err := jfroghttpclient.JfrogClientBuilder().
		SetInsecureTls(true).
		Build()
	assert.NoError(t, err, "Failed to create JFrog client")

	// Setup TokenService
	service := services.NewTokenService(client)
	serverDetails := accessAuth.NewAccessDetails()
	serverDetails.SetUrl(ts.URL + "/access")
	service.ServiceDetails = serverDetails

	// Test GetTokens without parameters
	params := services.GetTokensParams{}
	tokens, err := service.GetTokens(params)

	// Verify response
	assert.NoError(t, err)
	assert.NotNil(t, tokens)
	assert.Len(t, tokens, 2)
	assert.Equal(t, "test-token-1", tokens[0].TokenId)
	assert.Equal(t, "jfrt@test/users/admin", tokens[0].Subject)
	assert.Equal(t, "jfrt@test", tokens[0].Issuer)
	assert.True(t, tokens[0].Refreshable)
	assert.Equal(t, "test-token-2", tokens[1].TokenId)
	assert.Equal(t, "jfrt@test/users/user1", tokens[1].Subject)
	assert.Equal(t, "jfrt@test", tokens[1].Issuer)
	assert.False(t, tokens[1].Refreshable)

	// Test GetTokens with parameters
	paramsWithFilters := services.GetTokensParams{
		Username:        "admin",
		Refreshable:     utils.Pointer(true),
		OrderBy:         "description",
		DescendingOrder: utils.Pointer(true),
	}
	tokens, err = service.GetTokens(paramsWithFilters)

	// Verify response
	assert.NoError(t, err)
	assert.NotNil(t, tokens)
	assert.Len(t, tokens, 2)
}

func testGetTokenByID(t *testing.T) {
	initAccessTest(t)

	// Create mock server
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, http.MethodGet, r.Method)
		assert.Equal(t, "/access/api/v1/tokens/test-token-1", r.URL.Path)

		// Mock response for single token
		token := services.TokenInfo{
			TokenId:     "test-token-1",
			Subject:     "jfrt@test/users/admin",
			IssuedAt:    1640995200,
			Issuer:      "jfrt@test",
			Description: "Test token 1",
			Refreshable: true,
			Scope:       "applied-permissions/admin",
		}

		responseBody, err := json.Marshal(token)
		assert.NoError(t, err)

		w.WriteHeader(http.StatusOK)
		_, err = w.Write(responseBody)
		assert.NoError(t, err)
	})
	ts := httptest.NewServer(handler)
	defer ts.Close()

	// Setup JFrog client
	client, err := jfroghttpclient.JfrogClientBuilder().
		SetInsecureTls(true).
		Build()
	assert.NoError(t, err, "Failed to create JFrog client")

	// Setup TokenService
	service := services.NewTokenService(client)
	serverDetails := accessAuth.NewAccessDetails()
	serverDetails.SetUrl(ts.URL + "/access")
	service.ServiceDetails = serverDetails

	// Test GetTokenByID
	token, err := service.GetTokenByID("test-token-1")

	// Verify response
	assert.NoError(t, err)
	assert.NotNil(t, token)
	assert.Equal(t, "test-token-1", token.TokenId)
	assert.Equal(t, "jfrt@test/users/admin", token.Subject)
	assert.Equal(t, "jfrt@test", token.Issuer)
	assert.True(t, token.Refreshable)
	assert.Equal(t, "Test token 1", token.Description)

	// Test error case with empty token ID
	_, err = service.GetTokenByID("")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "token ID cannot be empty")
}

func testRevokeTokenByID(t *testing.T) {
	initAccessTest(t)

	// Create mock server
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, http.MethodDelete, r.Method)
		assert.Equal(t, "/access/api/v1/tokens/test-token-1", r.URL.Path)

		// Mock successful deletion response
		w.WriteHeader(http.StatusOK)
	})
	ts := httptest.NewServer(handler)
	defer ts.Close()

	// Setup JFrog client
	client, err := jfroghttpclient.JfrogClientBuilder().
		SetInsecureTls(true).
		Build()
	assert.NoError(t, err, "Failed to create JFrog client")

	// Setup TokenService
	service := services.NewTokenService(client)
	serverDetails := accessAuth.NewAccessDetails()
	serverDetails.SetUrl(ts.URL + "/access")
	service.ServiceDetails = serverDetails

	// Test RevokeTokenByID
	err = service.RevokeTokenByID("test-token-1")

	// Verify response
	assert.NoError(t, err)

	// Test error case with empty token ID
	err = service.RevokeTokenByID("")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "token ID cannot be empty")
}

func createRefreshableAccessTokenParams(expiredIn uint) services.CreateTokenParams {
	tokenParams := services.CreateTokenParams{}
	tokenParams.ExpiresIn = &expiredIn
	tokenParams.Refreshable = utils.Pointer(true)
	tokenParams.Audience = "*@*"
	return tokenParams
}

func createRefreshAccessTokenParams(token auth.CreateTokenResponseData) (refreshParams services.CreateTokenParams) {
	refreshParams = services.CreateTokenParams{}
	refreshParams.ExpiresIn = token.ExpiresIn
	refreshParams.Refreshable = utils.Pointer(true)
	refreshParams.GrantType = "refresh_token"
	refreshParams.TokenType = "Bearer"
	refreshParams.RefreshToken = token.RefreshToken
	refreshParams.AccessToken = token.AccessToken
	return
}
